/**
 * @file Utilities related to stage configs.
 */

import { cFamilyCompileDefault } from "@/constants/GuiBuilder/supportedLanguages";
import { Compile, Make, SettingsLang, TestCase } from "@/types/GuiBuilder";
import { createHash as createSHA256Hash } from "sha256-uint8array";
import { splitStringToArray } from "./stageRawConfig";

/**
 * Previews what the compilation command will the {@link Compile} stage run. It returns `null` if
 * preview is not available.
 *
 * The previewed command is derived from how the Grader would build the command in the implementation
 * of the `Compile` stage.
 *
 * @param lang Language of the config.
 * @param compile The `Compile` stage config.
 */
export const getCompilePreviewCommand = (lang: SettingsLang, compile: Compile): string | null => {
  const input = compile.input.join(" ");

  switch (lang.language) {
    case "c":
    case "cpp": {
      let compiler = lang.compiler;
      if (compiler === "clang") {
        if (lang.language === "cpp") compiler += "++";
        compiler += `-${lang.version}`;
      }
      const flags = compile.flags || cFamilyCompileDefault.flags;
      const output = compile.output || cFamilyCompileDefault.output;

      return `${compiler} ${flags} -o ${output} ${input}`;
    }
    default:
      return null;
  }
};

/**
 * Previews what the GNU Make command will the {@link Make} stage run.
 *
 * @param make The `Make` stage config.
 */
export const getMakePreviewCommand = (make: Make): string => {
  return `make ${make.args} ${make.targets.join(" ")}`.trimRight();
};

/**
 * @returns The largest test case ID in the given test cases.
 */
export const getTestCasesLargestId = (testCases: TestCase[]) => {
  if (testCases.length === 0) return 0; // Since `Math.max(...[])` returns `-Infinity`
  return Math.max(...testCases.map((test) => test.id));
};

/**
 * Returns the name of the file generated by the Grader that stores the test case's expected output.
 *
 * When the "auto-generate expected output of test cases" feature is enabled in the `StdioTest` stage,
 * the Grader will generate and save the expected output of the test case to a file with this name.
 *
 * @returns A string in the form of `${hash}-${id}`, where `hash` consists of 64 hexadecimal characters and
 * `id` is the test case ID.
 */
export const getTestCaseExpectedOutputHash = (testCase: TestCase): string => {
  const { id, file, args, stdin, file_stdin, _stdinInputMode } = testCase;
  const standardInput: Record<typeof _stdinInputMode, string> = {
    text: stdin ?? "",
    file: file_stdin ?? "",
    none: "",
  };
  // This hash generation algorithm should be the same as the one used in the Grader
  return createSHA256Hash()
    .update(id.toString())
    .update(file)
    .update(args ? splitStringToArray(args)?.join(" ") ?? "" : "")
    .update(standardInput[_stdinInputMode])
    .digest("hex")
    .concat(`-${id}`);
};

/**
 * Returns the neighbors IDs of the given `id` in the form of `[prevId, nextId]`.
 *
 * `prevId` is the ID which is smaller than and closest to `id`. For example, given `[2, 1, 4]`,
 * `prevId` of `4` is `2` because although both `2` and `1` are smaller than `4`, `2` is closer to `4`.
 * The same logic applies to `nextId`.
 *
 * `prevId` and `nextId` can be `null` if the neighbor does not exist.
 *
 * @param id The test case ID to search from.
 * @example
 * // Suppose `testCases` has test cases with IDs [2, 1, 4]
 * getTestCaseNeighborIds(testCases, 1); // returns [null, 2]
 * getTestCaseNeighborIds(testCases, 2); // returns [1, 4]
 * getTestCaseNeighborIds(testCases, 4); // returns [2, null]
 */
export const getTestCaseNeighborIds = (testCases: TestCase[], id: number) => {
  if (!testCases.some((testCase) => testCase.id === id)) {
    console.error(`Test case with ID ${id} not found in test cases.`);
    return [null, null] as const;
  }
  const testCasesSorted = [...testCases].sort((a, b) => a.id - b.id);
  const currentIdx = testCasesSorted.findIndex((testCase) => testCase.id === id);

  const prevId = currentIdx === 0 ? null : testCasesSorted[currentIdx - 1].id;
  const nextId = currentIdx === testCasesSorted.length - 1 ? null : testCasesSorted[currentIdx + 1].id;
  return [prevId, nextId] as const;
};

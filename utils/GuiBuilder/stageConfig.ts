/**
 * @file Utilities for manipulating stage configs.
 */

import { TestCase } from "@/types/GuiBuilder";
import { createHash as createSHA256Hash } from "sha256-uint8array";
import { splitStringToArray } from "./stageRawConfig";

/**
 * @returns The largest test case ID in the given test cases.
 */
export const getTestCasesLargestId = (testCases: TestCase[]) => {
  if (testCases.length === 0) return 0; // Since `Math.max(...[])` returns `-Infinity`
  return Math.max(...testCases.map((test) => test.id));
};

/**
 * Returns the name of the file generated by the Grader that stores the test case's expected output.
 *
 * When the "auto-generate expected output of test cases" feature is enabled in the `StdioTest` stage,
 * the Grader will generate and save the expected output of the test case to a file with this name.
 *
 * @returns A string in the form of `${hash}-${id}`, where `hash` consists of 64 hexadecimal characters and
 * `id` is the test case ID.
 */
export const getTestCaseExpectedOutputHash = (testCase: TestCase): string => {
  const { id, file, args, stdin, file_stdin, _stdinInputMode } = testCase;
  const standardInput: Record<typeof _stdinInputMode, string> = {
    text: stdin ?? "",
    file: file_stdin ?? "",
    none: "",
  };
  // This hash generation algorithm should be the same as the one used in the Grader
  return createSHA256Hash()
    .update(id.toString())
    .update(file)
    .update(args ? splitStringToArray(args)?.join(" ") ?? "" : "")
    .update(standardInput[_stdinInputMode])
    .digest("hex")
    .concat(`-${id}`);
};

/**
 * Returns the neighbors IDs of the given `id` in the form of `[prevId, nextId]`.
 *
 * `prevId` is the ID which is smaller than and closest to `id`. For example, given `[2, 1, 4]`,
 * `prevId` of `4` is `2` because although both `2` and `1` are smaller than `4`, `2` is closer to `4`.
 * The same logic applies to `nextId`.
 *
 * `prevId` and `nextId` can be `null` if the neighbor does not exist.
 *
 * @param id The test case ID to search from.
 * @example
 * // Suppose `testCases` has test cases with IDs [2, 1, 4]
 * getTestCaseNeighborIds(testCases, 1); // returns [null, 2]
 * getTestCaseNeighborIds(testCases, 2); // returns [1, 4]
 * getTestCaseNeighborIds(testCases, 4); // returns [2, null]
 */
export const getTestCaseNeighborIds = (testCases: TestCase[], id: number) => {
  if (!testCases.some((testCase) => testCase.id === id)) {
    console.error(`Test case with ID ${id} not found in test cases.`);
    return [null, null] as const;
  }
  const testCasesSorted = [...testCases].sort((a, b) => a.id - b.id);
  const currentIdx = testCasesSorted.findIndex((testCase) => testCase.id === id);

  const prevId = currentIdx === 0 ? null : testCasesSorted[currentIdx - 1].id;
  const nextId = currentIdx === testCasesSorted.length - 1 ? null : testCasesSorted[currentIdx + 1].id;
  return [prevId, nextId] as const;
};
